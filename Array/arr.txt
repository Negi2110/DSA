

### ‚úÖ **Array ‚Äì Time Complexity**

| Operation     | Time Complexity                                                                     | Explanation                                      |
| ------------- | ----------------------------------------------------------------------------------- | ------------------------------------------------ |
| **Access**    | **O(1)**                                                                            | Direct access by index using address arithmetic. |
| **Insertion** | **O(1)** *(at end, if space available)* / **O(n)** *(at position or when resizing)* | Inserting in the middle shifts elements.         |
| **Deletion**  | **O(1)** *(end)* / **O(n)** *(middle)*                                              | Shifting needed for maintaining order.           |
| **Traverse**  | **O(n)**                                                                            | Need to visit each element once.                 |
| **Search**    | **O(n)** *(unsorted ‚Äì linear)* / **O(log n)** *(sorted ‚Äì binary search)*            | Binary search works only if sorted.              |
| **Update**    | **O(1)**                                                                            | Direct index-based replacement.                  |

---

### ‚úÖ **Benefits**

* **Random access (O(1))** ‚Üí Direct indexing is very fast.
* **Cache-friendly** ‚Üí Elements stored in contiguous memory ‚Üí faster access (important in **DP, graphs, trees**).
* **Easy sorting** ‚Üí Can efficiently apply algorithms like quicksort, mergesort.
* **Foundation for other structures** ‚Üí Used in stacks, queues, heaps, hash tables, etc.

---

### ‚ö†Ô∏è **Limitations**

* **Fixed size** ‚Üí Once created, can‚Äôt grow/shrink dynamically (in static arrays).
* **Insertion/Deletion = O(n)** ‚Üí Requires shifting elements.
* **Inefficient for frequent modifications** ‚Üí Continuous shifting or resizing hurts performance.
* **Memory allocation** ‚Üí

  * **Static arrays** ‚Üí stack memory.
  * **Dynamic arrays (new/malloc)** ‚Üí heap memory.

---


Let‚Äôs go over **what dynamic arrays are**, **how they differ from normal arrays**, and **how to define them** (in C++ as example).

---

### ‚öôÔ∏è **1. Concept**

A **dynamic array** is an array whose **size can change at runtime** ‚Äî unlike a static array whose size must be known at compile time.
It‚Äôs usually allocated on the **heap** instead of the stack.

---

### üì¶ **2. How to Define Dynamic Arrays**

#### üß± **(a) Using `new` in C++**

```cpp
int* arr = new int[n];   // 'n' can be decided at runtime
```

* Memory is allocated on the **heap**.
* Access just like a normal array: `arr[i]`.
* Must **free memory** after use:

```cpp
delete[] arr;
```

**Example:**

```cpp
int n;
cin >> n;               // user decides size
int* arr = new int[n];

for(int i=0; i<n; i++)
    cin >> arr[i];

delete[] arr;           // prevent memory leak
```

---

#### üß∞ **(b) Using `std::vector` (Recommended in Modern C++)**

```cpp
#include <vector>
using namespace std;

vector<int> arr;          // empty dynamic array
arr.push_back(10);        // add elements dynamically
arr.push_back(20);

cout << arr[0];           // access like normal array
```

* Automatically **resizes** when needed.
* Manages its own memory (no need for `delete[]`).
* Offers many helpful functions (`push_back`, `size`, `pop_back`, etc.).

---

### ‚öñÔ∏è **3. Static vs Dynamic Array (Quick Comparison)**

| Feature         | Static Array          | Dynamic Array (`new` / `vector`)          |
| --------------- | --------------------- | ----------------------------------------- |
| **Size**        | Fixed at compile time | Can change at runtime                     |
| **Memory**      | Stack                 | Heap                                      |
| **Resizing**    | Not possible          | Possible (`vector` handles automatically) |
| **Performance** | Slightly faster       | Slight overhead for flexibility           |
| **Management**  | Manual                | `vector` auto-manages                     |

---

### ‚úÖ **Summary**

> **Dynamic array** ‚Üí Allocated on heap, size decided at runtime, can grow (if using `vector`), and supports efficient memory management.

---

Here‚Äôs the clean version for clarity:

int* arr = new int[n];  // memory allocated at runtime (heap)
delete[] arr;           // memory manually freed


‚úîÔ∏è Notes:

new int[n] dynamically allocates an array of size n on the heap.

delete[] arr; is the correct syntax for deallocating an array (not just delete arr;, which is for single objects).

So your code is perfectly correct and safe ‚úÖ
---

### **Dynamic Array (Theory ‚Äì C++)**

A **dynamic array** is a data structure whose **size can be changed during runtime**, unlike a static array whose size must be known at compile time.
It is stored in the **heap memory**, allowing flexible memory allocation.

When the array becomes full, a new larger block of memory is allocated, and the existing elements are copied to the new location.
This process allows the array to **grow or shrink dynamically** as elements are inserted or deleted.

In C++, a dynamic array can be created in two ways:

1. **Using `new` keyword (manually managed dynamic array):**

   ```cpp
   int* arr = new int[n]; // memory allocated at runtime
   delete[] arr;          // manually freed
   ```

   * Size decided at runtime.
   * Programmer is responsible for deallocating memory using `delete[]`.

2. **Using `std::vector` (standard dynamic array):**

   * `std::vector` is a **library implementation** of a dynamic array provided in the C++ Standard Template Library (STL).
   * It automatically manages memory and resizing.
   * When its capacity is full, it internally **allocates double the previous memory** and copies elements.
   * Provides built-in functions like `push_back()`, `pop_back()`, `size()`, and `insert()`.
   * Safer and more efficient than manually managed arrays.

---

### **Characteristics of Dynamic Array**

* Memory allocated on the **heap**.
* **Size can change** during program execution.
* **Random access** of elements is still **O(1)**.
* **Insertion** and **deletion** may take **O(n)** time due to shifting or resizing.
* Useful when the number of elements is **not known in advance**.

---

### **Difference Between Static and Dynamic Array**

| Feature           | Static Array          | Dynamic Array                                  |
| ----------------- | --------------------- | ---------------------------------------------- |
| Size              | Fixed at compile time | Can change at runtime                          |
| Memory            | Stack                 | Heap                                           |
| Resizing          | Not possible          | Possible                                       |
| Memory management | Automatic             | Manual or automatic (with `vector`)            |
| Example           | `int arr[10];`        | `int* arr = new int[n];` or `vector<int> arr;` |

---

### **Conclusion**

> In C++, **`std::vector` is the most common and efficient form of dynamic array**, as it provides automatic resizing, memory management, and additional utility functions while maintaining the advantages of contiguous memory and random access.

---

### **When to Use Arrays**

1. **To Implement Other Data Structures**
   Arrays form the foundation of many data structures such as **Stacks, Queues, Heaps, Hash Tables, and Matrices**.

   * Example: A stack or queue can be efficiently implemented using an array.

2. **For Caching, Tabulation, or Memoization (Dynamic Programming)**
   Arrays are ideal for **storing precomputed results** to avoid recomputation.

   * Example: `dp[i]` stores the result of a subproblem in Dynamic Programming.
   * Arrays are **cache-friendly** because elements are stored in **contiguous memory**, improving performance.

3. **In Graphs or Trees (Tracking Visited Nodes)**
   Arrays are often used to **keep track of visited nodes** or maintain adjacency lists/matrices.

   * Example: `visited[i] = true` when a node is explored in BFS/DFS.

4. **For Mathematical Computation or Numerical Problems**
   Arrays are useful for storing and processing **large numeric datasets** or mathematical series (like prefix sums, frequency counts, or polynomial coefficients).

5. **For Common Coding Patterns**
   Many algorithmic techniques rely on arrays because of **constant-time access** and **ordered storage**:

   * **Two Pointers Technique**
   * **Sliding Window**
   * **Fast and Slow Pointer**
   * **Prefix Sum / Suffix Sum**
   * **Sorting / Searching patterns**

---

### **In Summary**

> Use **arrays** when you need **fast random access**, **contiguous memory**, and **fixed or predictable indexing patterns**, especially in problems related to **DP, graphs, mathematical computation, or algorithmic patterns**.

Avoid arrays when the data structure needs frequent insertions/deletions, dynamic sizing, or sparse storage.
In such cases, Linked Lists, Vectors, or Hash Maps provide better performance and flexibility.

Multidimesional array-
garde in sub vs roll no matrix..each cell(roll no,grade)